import { describe, it, expect, vi } from 'vitest';
import { createJwtBearerAssertion, exchangeJwtBearer } from './auth.js';
import type { AuthorizationServerMetadata, JwtAssertionOptions, OAuthClientInformation } from '../shared/auth.js';

describe('createJwtBearerAssertion', () => {
    const baseOptions: JwtAssertionOptions = {
        issuer: 'client-id',
        subject: 'client-id',
        privateKey: 'a-string-secret-at-least-256-bits-long',
        alg: 'HS256'
    };

    it('returns pre-built assertion when provided', async () => {
        const assertion = await createJwtBearerAssertion('https://auth.example.com', undefined, {
            ...baseOptions,
            assertion: 'pre.built.jwt'
        });

        expect(assertion).toBe('pre.built.jwt');
    });

    it('creates a signed JWT when no pre-built assertion is provided', async () => {
        const assertion = await createJwtBearerAssertion('https://auth.example.com', undefined, baseOptions);

        // Basic shape check for JWT: three segments separated by dots
        const parts = assertion.split('.');
        expect(parts).toHaveLength(3);
    });

    it('creates a signed JWT when using a Uint8Array HMAC key', async () => {
        const secret = new TextEncoder().encode('a-string-secret-at-least-256-bits-long');

        const assertion = await createJwtBearerAssertion('https://auth.example.com', undefined, {
            issuer: 'client-id',
            subject: 'client-id',
            privateKey: secret,
            alg: 'HS256'
        });

        const parts = assertion.split('.');
        expect(parts).toHaveLength(3);
    });

    it('creates a signed JWT when using a symmetric JWK key', async () => {
        const jwk: Record<string, unknown> = {
            kty: 'oct',
            // "a-string-secret-at-least-256-bits-long" base64url-encoded
            k: 'YS1zdHJpbmctc2VjcmV0LWF0LWxlYXN0LTI1Ni1iaXRzLWxvbmc',
            alg: 'HS256'
        };

        const assertion = await createJwtBearerAssertion('https://auth.example.com', undefined, {
            issuer: 'client-id',
            subject: 'client-id',
            privateKey: jwk,
            alg: 'HS256'
        });

        const parts = assertion.split('.');
        expect(parts).toHaveLength(3);
    });

    it('creates a signed JWT when using an RSA PEM private key', async () => {
        /**
 * Generated by the following command:
 1) Generate an RSA private key (PKCS#1 format)
 ```bash
 openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out rsa-key.pem
 ```
 2) Convert it to PKCS#8 (what `jose.importPKCS8` expects)
 ```bash
 openssl pkcs8 -topk8 -nocrypt -in rsa-key.pem -out rsa-key-pkcs8.pem
 ```
 */
        const pem = `-----BEGIN PRIVATE KEY-----
MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCruEwXtZ4MXsYl
ONRMtvBnOZNtnYWlO1KJs93gROCxzRzHz8I5dSzNBYgk5fwncd4L/ZJn3Ue8DsZL
0KzF1W9wweq/EsVYwhTxkLsfkaVVJld4DuYlAATCMiQYN7f4LfdmXaz1o+2kB5Ug
Ae9DqcrSXWcO7gbt1ABJdomPuwFurD9bZKANB/zM+MsAohXGVDoN8o7QH6hWFT/4
7x3ANoH2oT2mvF58F9Fh6DkGcE9BG3+Ze3TOoCx2DhqdjK8/artxIKigiVXUxLwx
4FB/cSmdh3KpldC1UkmPpyzwMGKe4BlsghXxssyuNBMEi3J1+peiMzN0c4YU5B6A
9jFLMsQXAgMBAAECggEAOxnnNpHPn7pOwCjbCLw96YkrcKKyiLfuJG6/gpyyKP/L
VAnxcw0dKkMpJGnzazAJmF7hsNW8BsGfBiEAFebrwAc94B15xp6lzq5dePQLz06u
9CdMlpd3C89uFNe4fbZ0W8sJ6FFPTRE/BhEkZElgAR8chUrvH5PDtYUSu2FFkO0u
8/RFEPj0urL93kzwaWzff91px82Tn4sak5rK6NfeeoLabyUAoc+E+vDvB8RZW3/1
sdQ/zp09XZqsw45WS8oHJmDlV/eB2tICha/bC/FygkZY+SmkX4L9a6rz2f+mjlHc
afSYMBLa93/Q4HUzeZcP5HOKr7vM/uC06aYqwXfJAQKBgQDiKBh8LJPeLkrzML7J
160vY/T5b92qt4B8odR6jgySDg/4YbW5Ie6Lydim9G+yu4xodRpJZ0tm9r02Sieq
gvYSzPrdbuiU7jnwCBmeDsoaSsxy+zKNE5TBRBDbwmuaQHlkdDKp9Bd90itp8qMm
YGBu1Rqn7A/xCWkmZA16TaGwtwKBgQDCYT/Hv/iSbzIgbzQTESP3f2WSaUye0MKu
kASLo3IsWgwyrdtLEZ0BYMoibasRj0351wtk2FxOy1t8+Wz80BBi57MTaZgbcYHi
XcaB0imBl+hQinK6PnY/LJN2ZPp7fMSPJ8kE4kmxcAAH0A56UDpOn5Fnle9PMS/W
cjj5Xd9noQKBgEM9QpJgupH7V4NYgdEHE9GcOXCUBubD6iqj/sV1SF2AWtUxT9M8
OG1NVOHGmRMd2dAQyQD7+hohz/29LG/wwfKzCP8fA32MGqO39M3efc41YPXqo4v4
P2j6sLx14IIbGzx3o7yN+xIIk6nLXyCA1Qr+xw8YC2FRt/aXFr6/KAyfAoGAThZz
YPOmEG3LXWxPJznDkTIExAS5WzPSgf4pVU+cFmU2cUWWy1mQEXWovpwAFVXUpYHW
efTRYHYhkttBBW8wpgsezbWl/aBj5WR20sBzHDTCh1iXLmrZZheqRe3bErDU5g29
m9CsejPcT0cuCcUhJ2TDLTH2qYHBDg1lBgjILwECgYB7J5HgEl2pgg+RxuiQd11x
ERSttiQtJ91cm+rOS0DAoviTDd1lvvrKlSxw9eMKO1UX/nLkFeEAnxxc7RPlsMb/
wZs2jVskGA6OxU/II0nCh9C+hp1LV4vl5Hy1mM3Lkqa/I/AC4kJdvTwi45lXpM9o
btHHccicX+r3BsSv5adOxQ==
-----END PRIVATE KEY-----`;

        const assertion = await createJwtBearerAssertion('https://auth.example.com', undefined, {
            issuer: 'client-id',
            subject: 'client-id',
            privateKey: pem,
            alg: 'RS256'
        });

        const parts = assertion.split('.');
        expect(parts).toHaveLength(3);
    });

    it('throws when using an unsupported algorithm', async () => {
        await expect(
            createJwtBearerAssertion('https://auth.example.com', undefined, {
                issuer: 'client-id',
                subject: 'client-id',
                privateKey: 'a-string-secret-at-least-256-bits-long',
                // This will hit the explicit Unsupported algorithm branch in createJwtBearerAssertion
                alg: 'none' as unknown as string
            })
        ).rejects.toThrow('Unsupported algorithm none');
    });

    it('throws when jose cannot import an invalid RSA PEM key', async () => {
        const badPem = '-----BEGIN PRIVATE KEY-----\nnot-a-valid-key\n-----END PRIVATE KEY-----';

        await expect(
            createJwtBearerAssertion('https://auth.example.com', undefined, {
                issuer: 'client-id',
                subject: 'client-id',
                privateKey: badPem,
                alg: 'RS256'
            })
        ).rejects.toThrow(/Invalid character/);
    });

    it('throws when jose cannot import a mismatched JWK key', async () => {
        const jwk: Record<string, unknown> = {
            kty: 'oct',
            k: 'c2VjcmV0LWtleQ', // "secret-key" base64url
            alg: 'HS256'
        };

        await expect(
            createJwtBearerAssertion('https://auth.example.com', undefined, {
                issuer: 'client-id',
                subject: 'client-id',
                privateKey: jwk,
                // Ask for an RSA algorithm with an octet key, which should cause jose.importJWK to fail
                alg: 'RS256'
            })
        ).rejects.toThrow(/Key for the RS256 algorithm must be one of type CryptoKey, KeyObject, or JSON Web Key/);
    });
});

describe('exchangeJwtBearer', () => {
    it('posts jwt-bearer grant with assertion, scope and resource', async () => {
        const mockFetch = vi.fn().mockResolvedValue({
            ok: true,
            json: async () => ({
                access_token: 'jwt_bearer_token',
                token_type: 'bearer',
                expires_in: 3600
            })
        });

        const metadata: AuthorizationServerMetadata = {
            issuer: 'https://auth.example.com',
            authorization_endpoint: 'https://auth.example.com/authorize',
            token_endpoint: 'https://auth.example.com/token',
            response_types_supported: ['code']
        };

        const clientInformation: OAuthClientInformation = {
            client_id: 'c1',
            client_secret: 's1'
        };

        const tokens = await exchangeJwtBearer('https://auth.example.com', {
            metadata,
            clientInformation,
            jwtOptions: {
                issuer: 'c1',
                subject: 'c1',
                privateKey: 'a-string-secret-at-least-256-bits-long',
                alg: 'HS256'
            },
            scope: 'read write',
            resource: new URL('https://api.example.com/mcp'),
            fetchFn: mockFetch
        });

        expect(tokens.access_token).toBe('jwt_bearer_token');
        expect(mockFetch).toHaveBeenCalledTimes(1);
        const [url, init] = mockFetch.mock.calls[0];
        expect(String(url)).toBe('https://auth.example.com/token');
        const body = String((init as RequestInit).body);
        expect(body).toContain('grant_type=' + encodeURIComponent('urn:ietf:params:oauth:grant-type:jwt-bearer'));
        expect(body).toContain('scope=read+write');
        expect(body).toContain('resource=' + encodeURIComponent('https://api.example.com/mcp'));
        expect(body).toContain('assertion=');
    });
});
