/**
 * Schema Generation Script using ts-to-zod as a library
 *
 * This script generates Zod schemas from spec.types.ts and performs necessary
 * post-processing for compatibility with this project.
 *
 * ## Why Library-based Generation?
 *
 * Using ts-to-zod as a library (vs CLI) provides:
 * - Access to configuration options like getSchemaName, keepComments
 * - Ability to generate integration tests that verify type-schema alignment
 * - Programmatic post-processing with full control
 *
 * ## Post-Processing
 *
 * ts-to-zod has limitations that require post-processing:
 *
 * ### 1. Zod Import Path (`"zod"` ‚Üí `"zod/v4"`)
 * ts-to-zod generates `import { z } from "zod"` but this project uses `"zod/v4"`.
 *
 * ### 2. Index Signatures (`z.record().and()` ‚Üí `z.looseObject()`)
 * TypeScript index signatures like `[key: string]: unknown` are translated to
 * `z.record(z.string(), z.unknown()).and(z.object({...}))`, which creates
 * ZodIntersection types that don't support `.extend()`. We replace these with
 * `z.looseObject()`.
 *
 * ### 3. TypeOf Expressions (`z.any()` ‚Üí literal values)
 * ts-to-zod can't translate `typeof CONST` expressions and falls back to `z.any()`.
 * We replace these with the actual literal values from the spec:
 * - `jsonrpc: z.any()` ‚Üí `jsonrpc: z.literal("2.0")`
 * - `code: z.any()` for URL_ELICITATION_REQUIRED ‚Üí `code: z.literal(-32042)`
 *
 * @see https://github.com/fabien0102/ts-to-zod
 */
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { generate } from 'ts-to-zod';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PROJECT_ROOT = join(__dirname, '..');

const SPEC_TYPES_FILE = join(PROJECT_ROOT, 'src', 'spec.types.ts');
const GENERATED_DIR = join(PROJECT_ROOT, 'src', 'generated');
const SCHEMA_OUTPUT_FILE = join(GENERATED_DIR, 'spec.schemas.ts');
const SCHEMA_TEST_OUTPUT_FILE = join(GENERATED_DIR, 'spec.schemas.zod.test.ts');

async function main() {
    console.log('üîß Generating Zod schemas from spec.types.ts...\n');

    // Ensure generated directory exists
    if (!existsSync(GENERATED_DIR)) {
        mkdirSync(GENERATED_DIR, { recursive: true });
    }

    const sourceText = readFileSync(SPEC_TYPES_FILE, 'utf-8');

    const result = generate({
        sourceText,
        keepComments: true,
        skipParseJSDoc: false,
        // Use PascalCase naming to match existing types.ts convention
        // e.g., ProgressToken ‚Üí ProgressTokenSchema
        getSchemaName: (typeName: string) => `${typeName}Schema`,
    });

    if (result.errors.length > 0) {
        console.error('‚ùå Generation errors:');
        for (const error of result.errors) {
            console.error(`  - ${error}`);
        }
        process.exit(1);
    }

    if (result.hasCircularDependencies) {
        console.warn('‚ö†Ô∏è  Warning: Circular dependencies detected in types');
    }

    // Generate schema file with relative import to spec.types
    let schemasContent = result.getZodSchemasFile('../spec.types.js');
    schemasContent = postProcess(schemasContent);

    writeFileSync(SCHEMA_OUTPUT_FILE, schemasContent, 'utf-8');
    console.log(`‚úÖ Written: ${SCHEMA_OUTPUT_FILE}`);

    // Generate integration tests that verify schemas match TypeScript types
    const testsContent = result.getIntegrationTestFile(
        '../spec.types.js',
        './spec.schemas.js',
    );
    if (testsContent) {
        const processedTests = postProcessTests(testsContent);
        writeFileSync(SCHEMA_TEST_OUTPUT_FILE, processedTests, 'utf-8');
        console.log(`‚úÖ Written: ${SCHEMA_TEST_OUTPUT_FILE}`);
    }

    console.log('\nüéâ Schema generation complete!');
}

/**
 * Post-process generated schemas for project compatibility.
 */
function postProcess(content: string): string {
    // 1. Update import to use zod/v4
    content = content.replace(
        'import { z } from "zod";',
        'import { z } from "zod/v4";',
    );

    // 2. Replace z.record().and(z.object({...})) with z.looseObject({...})
    // Uses brace-counting to handle nested objects correctly.
    content = replaceRecordAndWithLooseObject(content);

    // 3. Fix typeof expressions that became z.any()
    // ts-to-zod can't translate `typeof CONST` and falls back to z.any()
    content = fixTypeOfExpressions(content);

    // 4. Remap notification/request schemas to SDK-compatible hierarchy
    // (extend Notification/Request instead of JSONRPCNotification/JSONRPCRequest)
    content = remapToSdkHierarchy(content);

    // 5. Add integer refinements to match SDK types.ts
    content = addIntegerRefinements(content);

    // 6. Add header comment
    content = content.replace(
        '// Generated by ts-to-zod',
        `// Generated by ts-to-zod
// Post-processed for Zod v4 compatibility
// Run: npm run generate:schemas`,
    );

    return content;
}

/**
 * Fix typeof expressions that ts-to-zod couldn't translate.
 *
 * In the spec, these patterns use `typeof CONST`:
 * - `jsonrpc: typeof JSONRPC_VERSION` where JSONRPC_VERSION = "2.0"
 * - `code: typeof URL_ELICITATION_REQUIRED` where URL_ELICITATION_REQUIRED = -32042
 *
 * ts-to-zod generates `z.any()` for these, which we replace with proper literals.
 */
function fixTypeOfExpressions(content: string): string {
    // Fix jsonrpc: z.any() ‚Üí jsonrpc: z.literal("2.0")
    // This appears in JSONRPCRequest, JSONRPCNotification, JSONRPCResponse schemas
    content = content.replace(
        /jsonrpc: z\.any\(\)/g,
        'jsonrpc: z.literal("2.0")'
    );

    // Note: URL_ELICITATION_REQUIRED code field is inside a more complex structure
    // and may need specific handling if tests fail

    return content;
}

/**
 * Add integer refinements to numeric schemas.
 *
 * The SDK uses .int() for:
 * - ProgressToken (numeric tokens should be integers)
 * - RequestId (numeric IDs should be integers)
 *
 * This matches the manual types.ts behavior.
 */
function addIntegerRefinements(content: string): string {
    // ProgressTokenSchema: z.union([z.string(), z.number()]) ‚Üí z.union([z.string(), z.number().int()])
    content = content.replace(
        /export const ProgressTokenSchema = z\.union\(\[z\.string\(\), z\.number\(\)\]\)/,
        'export const ProgressTokenSchema = z.union([z.string(), z.number().int()])'
    );

    // RequestIdSchema: z.union([z.string(), z.number()]) ‚Üí z.union([z.string(), z.number().int()])
    content = content.replace(
        /export const RequestIdSchema = z\.union\(\[z\.string\(\), z\.number\(\)\]\)/,
        'export const RequestIdSchema = z.union([z.string(), z.number().int()])'
    );

    return content;
}

/**
 * Remap notification and request schemas to use SDK-compatible hierarchy.
 *
 * The spec defines:
 * - XxxNotification extends JSONRPCNotification (includes jsonrpc field)
 * - XxxRequest extends JSONRPCRequest (includes jsonrpc, id fields)
 *
 * The SDK types.ts uses:
 * - XxxNotification extends Notification (no jsonrpc field)
 * - XxxRequest extends Request (no jsonrpc, id fields)
 *
 * This allows the jsonrpc/id fields to be handled at the transport layer.
 */
function remapToSdkHierarchy(content: string): string {
    // List of notifications that should extend NotificationSchema instead of JSONRPCNotificationSchema
    const notifications = [
        'CancelledNotification',
        'InitializedNotification',
        'ProgressNotification',
        'ResourceListChangedNotification',
        'ResourceUpdatedNotification',
        'PromptListChangedNotification',
        'ToolListChangedNotification',
        'TaskStatusNotification',
        'LoggingMessageNotification',
        'RootsListChangedNotification',
        'ElicitationCompleteNotification',
    ];

    // List of requests that should extend RequestSchema instead of JSONRPCRequestSchema
    const requests = [
        'InitializeRequest',
        'PingRequest',
        'ListResourcesRequest',
        'ListResourceTemplatesRequest',
        'ReadResourceRequest',
        'SubscribeRequest',
        'UnsubscribeRequest',
        'ListPromptsRequest',
        'GetPromptRequest',
        'ListToolsRequest',
        'CallToolRequest',
        'GetTaskRequest',
        'ListTasksRequest',
        'GetTaskPayloadRequest',
        'CancelTaskRequest',
        'SetLevelRequest',
        'CreateMessageRequest',
        'CompleteRequest',
        'ListRootsRequest',
        'ElicitRequest',
    ];

    // Replace JSONRPCNotificationSchema.extend with NotificationSchema.extend for specific schemas
    for (const name of notifications) {
        content = content.replace(
            new RegExp(`export const ${name}Schema = JSONRPCNotificationSchema\\.extend\\(`),
            `export const ${name}Schema = NotificationSchema.extend(`
        );
    }

    // Replace JSONRPCRequestSchema.extend with RequestSchema.extend for specific schemas
    for (const name of requests) {
        content = content.replace(
            new RegExp(`export const ${name}Schema = JSONRPCRequestSchema\\.extend\\(`),
            `export const ${name}Schema = RequestSchema.extend(`
        );
    }

    return content;
}

/**
 * Replace z.record(z.string(), z.unknown()).and(z.object({...})) with z.looseObject({...})
 * Uses brace-counting to handle nested objects correctly.
 */
function replaceRecordAndWithLooseObject(content: string): string {
    const pattern = 'z.record(z.string(), z.unknown()).and(z.object({';
    let result = content;
    let startIndex = 0;

    while (true) {
        const matchStart = result.indexOf(pattern, startIndex);
        if (matchStart === -1) break;

        // Find the matching closing brace for z.object({
        const objectStart = matchStart + pattern.length;
        let braceCount = 1;
        let i = objectStart;

        while (i < result.length && braceCount > 0) {
            if (result[i] === '{') braceCount++;
            else if (result[i] === '}') braceCount--;
            i++;
        }

        // i now points after the closing } of z.object({...})
        // Check if followed by ))
        if (result.slice(i, i + 2) === '))') {
            const objectContent = result.slice(objectStart, i - 1);
            const replacement = `z.looseObject({${objectContent}})`;
            result = result.slice(0, matchStart) + replacement + result.slice(i + 2);
            startIndex = matchStart + replacement.length;
        } else {
            startIndex = i;
        }
    }

    return result;
}

/**
 * Post-process generated integration tests.
 */
function postProcessTests(content: string): string {
    content = content.replace(
        'import { z } from "zod";',
        'import { z } from "zod/v4";',
    );

    content = content.replace(
        '// Generated by ts-to-zod',
        `// Generated by ts-to-zod
// Integration tests verifying schemas match TypeScript types
// Run: npm run generate:schemas`,
    );

    return content;
}

main().catch((error) => {
    console.error('‚ùå Schema generation failed:', error);
    process.exit(1);
});
