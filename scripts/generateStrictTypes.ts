#!/usr/bin/env node
import { readFileSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

// Read the original types.ts file
const typesPath = join(__dirname, '../src/types.ts');
const strictTypesPath = join(__dirname, '../src/strictTypes.ts');

let content = readFileSync(typesPath, 'utf-8');

// Remove the @deprecated comment block
const deprecatedCommentPattern = /\/\*\*\s*\n\s*\*\s*@deprecated[\s\S]*?\*\/\s*\n/;
content = content.replace(deprecatedCommentPattern, '');

// Add header comment
const header = `/**
 * Types remove unknown
 * properties to maintaining compatibility with protocol extensions.
 * 
 * - Protocol compatoble: Unknown fields from extended implementations are removed, not rejected
 * - Forward compatibility: Works with servers/clients that have additional fields
 * 
 * @generated by scripts/generateStrictTypes.ts
 */

`;

// Replace all .passthrough() with a temporary marker
content = content.replace(/\.passthrough\(\)/g, '.__TEMP_MARKED_FOR_REMOVAL__()');

// Special handling for experimental and capabilities that should remain open
// These are explicitly designed to be extensible
const patternsToKeepOpen = [
  // Keep experimental fields open as they're meant for extensions
  /experimental: z\.optional\(z\.object\(\{\}\)\.__TEMP_MARKED_FOR_REMOVAL__\(\)\)/g,
  // Keep _meta fields open as they're meant for arbitrary metadata
  /_meta: z\.optional\(z\.object\(\{\}\)\.__TEMP_MARKED_FOR_REMOVAL__\(\)\)/g,
  // Keep JSON Schema properties open as they can have arbitrary fields
  /properties: z\.optional\(z\.object\(\{\}\)\.__TEMP_MARKED_FOR_REMOVAL__\(\)\)/g,
  // Keep BaseRequestParamsSchema passthrough for JSON-RPC param compatibility
  /const BaseRequestParamsSchema = z\s*\n\s*\.object\([\s\S]*?\)\s*\n\s*\.__TEMP_MARKED_FOR_REMOVAL__\(\)/g,
  // Keep BaseNotificationParamsSchema passthrough for JSON-RPC param compatibility  
  /const BaseNotificationParamsSchema = z\s*\n\s*\.object\([\s\S]*?\)\s*\n\s*\.__TEMP_MARKED_FOR_REMOVAL__\(\)/g,
  // Keep RequestMetaSchema passthrough for extensibility
  /const RequestMetaSchema = z\s*\n\s*\.object\([\s\S]*?\)\s*\n\s*\.__TEMP_MARKED_FOR_REMOVAL__\(\)/g,
  // Keep structuredContent passthrough for tool-specific output
  /structuredContent: z\.object\(\{\}\)\.__TEMP_MARKED_FOR_REMOVAL__\(\)\.optional\(\)/g,
  // Keep metadata passthrough for provider-specific data in sampling
  /metadata: z\.optional\(z\.object\(\{\}\)\.__TEMP_MARKED_FOR_REMOVAL__\(\)\)/g,
];

// Revert marker back to passthrough for these special cases
patternsToKeepOpen.forEach(pattern => {
  content = content.replace(pattern, (match) =>
    match.replace('.__TEMP_MARKED_FOR_REMOVAL__()', '.passthrough()')
  );
});

// Remove the temporary marker from all remaining locations (these become no modifier)
content = content.replace(/\.__TEMP_MARKED_FOR_REMOVAL__\(\)/g, '');

// Add a comment explaining the difference
const explanation = `
/**
 * Note: The following remain open (using .passthrough()):
 * - experimental: Designed for protocol extensions
 * - _meta: Designed for arbitrary metadata
 * - properties: JSON Schema properties that can have arbitrary fields
 * - BaseRequestParamsSchema: Required for JSON-RPC param compatibility
 * - BaseNotificationParamsSchema: Required for JSON-RPC param compatibility
 * - RequestMetaSchema: Required for protocol extensibility
 * - structuredContent: Tool-specific output that can have arbitrary fields
 * - metadata: Provider-specific metadata in sampling requests
 * 
 * All other objects use default behavior (no modifier) to remove unknown properties while
 * maintaining compatibility with extended protocols.
 */
`;

// Insert the explanation after the imports
const importEndIndex = content.lastIndexOf('import');
const importEndLineIndex = content.indexOf('\n', importEndIndex);
content = content.slice(0, importEndLineIndex + 1) + explanation + content.slice(importEndLineIndex + 1);

// Write the strict types file
writeFileSync(strictTypesPath, header + content);

console.log('Generated strictTypes.ts successfully!');
