on:
    push:
        branches:
            - main
    pull_request:
    workflow_dispatch:
    release:
        types: [published]

concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: true

jobs:
    build:
        runs-on: ubuntu-latest

        steps:
            - uses: actions/checkout@v6

            - name: Install pnpm
              uses: pnpm/action-setup@v4
              id: pnpm-install
              with:
                  run_install: false
            - uses: actions/setup-node@v6
              with:
                  node-version: 24
                  cache: pnpm
                  cache-dependency-path: pnpm-lock.yaml

            - run: pnpm install
            - run: pnpm run check:all
            - run: pnpm run build:all

    test:
        runs-on: ubuntu-latest
        strategy:
            fail-fast: false
            matrix:
                node-version: [20, 22, 24]

        steps:
            - uses: actions/checkout@v6

            - name: Install pnpm
              uses: pnpm/action-setup@v4
              id: pnpm-install
              with:
                  run_install: false
            - uses: actions/setup-node@v6
              with:
                  node-version: ${{ matrix.node-version }}
                  cache: pnpm
                  cache-dependency-path: pnpm-lock.yaml

            - run: pnpm install

            - run: pnpm test:all

    publish:
        runs-on: ubuntu-latest
        if: github.event_name == 'release'
        environment: release
        needs: [build, test]

        permissions:
            contents: read
            id-token: write

        steps:
            - uses: actions/checkout@v4

            - name: Install pnpm
              uses: pnpm/action-setup@v4
              id: pnpm-install
              with:
                  run_install: false
            - uses: actions/setup-node@v4
              with:
                  node-version: 24
                  cache: pnpm
                  cache-dependency-path: pnpm-lock.yaml
                  registry-url: 'https://registry.npmjs.org'
            - run: pnpm install

            - name: Determine npm tag
              id: npm-tag
              run: |
                  VERSION=$(node -p "require('./package.json').version")
                  # Check if this is a beta release
                  if [[ "$VERSION" == *"-beta"* ]]; then
                    echo "tag=--tag beta" >> $GITHUB_OUTPUT
                  # Check if this release is from a non-primary branch (patch/maintenance release)
                  elif [[ "${{ github.event.release.target_commitish }}" != "main" && "${{ github.event.release.target_commitish }}" != "v1.x" ]]; then
                    # Use "release-X.Y" as tag for old branch releases (e.g., "release-1.23" for 1.23.x)
                    # npm tags are mutable pointers to versions (like "latest" pointing to 1.24.3).
                    # Using "release-1.23" means users can `npm install @modelcontextprotocol/sdk@release-1.23`
                    # to get the latest patch on that minor version, and the tag updates if we
                    # release 1.23.2, 1.23.3, etc.
                    # Note: Can't use "v1.23" because npm rejects tags that look like semver ranges.
                    MAJOR_MINOR=$(echo "$VERSION" | cut -d. -f1,2)
                    echo "tag=--tag release-${MAJOR_MINOR}" >> $GITHUB_OUTPUT
                  else
                    echo "tag=" >> $GITHUB_OUTPUT
                  fi

            - run: pnpm publish --provenance --access public ${{ steps.npm-tag.outputs.tag }}
              env:
                  NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

    notify:
        name: Notify maintainers
        runs-on: ubuntu-latest
        needs: [build, test]
        if: >-
            github.event_name == 'pull_request' &&
            !github.event.pull_request.draft
        permissions: {}
        steps:
            - name: Notify Slack
              env:
                  MAINTAINER_MAP: ${{ secrets.MAINTAINER_MAP }}
                  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
                  PR_URL: ${{ github.event.pull_request.html_url }}
                  PR_NUMBER: ${{ github.event.pull_request.number }}
                  PR_TITLE: ${{ github.event.pull_request.title }}
                  PR_AUTHOR: ${{ github.event.pull_request.user.login }}
              run: |
                  # Check if PR author is on the team (triggers list)
                  if ! echo "$MAINTAINER_MAP" | jq -e --arg author "$PR_AUTHOR" '.triggers | index($author)' > /dev/null 2>&1; then
                    echo "PR author $PR_AUTHOR is not on the team, skipping notification"
                    exit 0
                  fi

                  # Pick a random reviewer
                  ALL_REVIEWERS=$(echo "$MAINTAINER_MAP" | jq -r '.reviewers | keys[]')
                  REVIEWERS_ARRAY=($ALL_REVIEWERS)
                  if [ ${#REVIEWERS_ARRAY[@]} -eq 0 ]; then
                    echo "No reviewers configured"
                    exit 0
                  fi
                  REVIEWER=${REVIEWERS_ARRAY[$((RANDOM % ${#REVIEWERS_ARRAY[@]}))]}
                  SLACK_ID=$(echo "$MAINTAINER_MAP" | jq -r --arg user "$REVIEWER" '.reviewers[$user].slack')

                  # Post to Slack
                  SLACK_TEXT="${PR_URL} \"${PR_TITLE}\" by ${PR_AUTHOR}"
                  curl -sf -X POST "$SLACK_WEBHOOK_URL" \
                    -H 'Content-Type: application/json' \
                    -d "$(jq -n --arg text "$SLACK_TEXT" --arg user_id "$SLACK_ID" '{text: $text, user_id: $user_id}')" || echo "::warning::Slack notification failed"